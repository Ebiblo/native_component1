{"version":3,"sources":["useTransition.ts"],"names":["useTransition","animationDuration","animationEasing","contentPanGestureState","contentPanGestureTranslationY","contentPanGestureVelocityY","handlePanGestureState","handlePanGestureTranslationY","handlePanGestureVelocityY","scrollableContentOffsetY","snapPoints","initialPosition","currentGesture","GESTURE","UNDETERMINED","currentPosition","isPanningContent","State","ACTIVE","isPanningHandle","isPanning","shouldAnimate","manualSnapToPoint","clock","config","toValue","Animated","Value","duration","easing","animationState","finished","position","frameTime","time","finishTiming","translateY","CONTENT","velocityY","isAnimationInterrupted","HANDLE","END"],"mappings":"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","sourcesContent":["import { useMemo } from 'react';\nimport Animated, {\n  eq,\n  set,\n  add,\n  greaterOrEq,\n  lessOrEq,\n  and,\n  not,\n  clockRunning,\n  startClock,\n  timing,\n  stopClock,\n  multiply,\n  neq,\n  onChange,\n  or,\n  cond,\n  block,\n  // debug,\n} from 'react-native-reanimated';\nimport { State } from 'react-native-gesture-handler';\nimport { useClock, useValue, snapPoint } from 'react-native-redash';\nimport type { BottomSheetAnimationConfigs } from './types';\nimport { GESTURE } from '../../constants';\n\ninterface TransitionProps extends Required<BottomSheetAnimationConfigs> {\n  contentPanGestureState: Animated.Value<State>;\n  contentPanGestureTranslationY: Animated.Value<number>;\n  contentPanGestureVelocityY: Animated.Value<number>;\n\n  handlePanGestureState: Animated.Value<State>;\n  handlePanGestureTranslationY: Animated.Value<number>;\n  handlePanGestureVelocityY: Animated.Value<number>;\n\n  scrollableContentOffsetY: Animated.Value<number>;\n  snapPoints: number[];\n  initialPosition: number;\n}\n\nexport const useTransition = ({\n  animationDuration,\n  animationEasing,\n  contentPanGestureState,\n  contentPanGestureTranslationY,\n  contentPanGestureVelocityY,\n  handlePanGestureState,\n  handlePanGestureTranslationY,\n  handlePanGestureVelocityY,\n  scrollableContentOffsetY,\n  snapPoints,\n  initialPosition,\n}: TransitionProps) => {\n  const currentGesture = useValue<GESTURE>(GESTURE.UNDETERMINED);\n  const currentPosition = useValue(initialPosition);\n\n  const isPanningContent = useMemo(\n    () => eq(contentPanGestureState, State.ACTIVE),\n    [contentPanGestureState]\n  );\n  const isPanningHandle = useMemo(\n    () => eq(handlePanGestureState, State.ACTIVE),\n    [handlePanGestureState]\n  );\n  const isPanning = useMemo(() => or(isPanningContent, isPanningHandle), [\n    isPanningContent,\n    isPanningHandle,\n  ]);\n  const shouldAnimate = useValue(0);\n  const manualSnapToPoint = useValue<number>(-1);\n\n  const clock = useClock();\n  const config = useMemo(\n    () => ({\n      toValue: new Animated.Value(0),\n      duration: animationDuration,\n      easing: animationEasing,\n    }),\n    [animationEasing, animationDuration]\n  );\n\n  const animationState = useMemo(\n    () => ({\n      finished: new Animated.Value(0),\n      position: new Animated.Value(initialPosition),\n      frameTime: new Animated.Value(0),\n      time: new Animated.Value(0),\n    }),\n    [initialPosition]\n  );\n\n  const finishTiming = useMemo(\n    () => [\n      set(currentGesture, GESTURE.UNDETERMINED),\n      set(shouldAnimate, 0),\n      set(currentPosition, config.toValue),\n      set(animationState.frameTime, 0),\n      set(animationState.time, 0),\n      stopClock(clock),\n    ],\n    [\n      animationState.frameTime,\n      animationState.time,\n      clock,\n      config.toValue,\n      currentGesture,\n      currentPosition,\n      shouldAnimate,\n    ]\n  );\n\n  const translateY = useMemo(\n    () =>\n      cond(\n        eq(currentGesture, GESTURE.CONTENT),\n        cond(\n          eq(currentPosition, 0),\n          add(\n            contentPanGestureTranslationY,\n            multiply(scrollableContentOffsetY, -1)\n          ),\n          contentPanGestureTranslationY\n        ),\n        handlePanGestureTranslationY\n      ),\n    [\n      contentPanGestureTranslationY,\n      currentGesture,\n      currentPosition,\n      handlePanGestureTranslationY,\n      scrollableContentOffsetY,\n    ]\n  );\n  const velocityY = useMemo(\n    () =>\n      cond(\n        eq(currentGesture, GESTURE.CONTENT),\n        contentPanGestureVelocityY,\n        handlePanGestureVelocityY\n      ),\n    [contentPanGestureVelocityY, currentGesture, handlePanGestureVelocityY]\n  );\n  const isAnimationInterrupted = useMemo(\n    () => and(clockRunning(clock), or(isPanning, neq(manualSnapToPoint, -1))),\n    [clock, isPanning, manualSnapToPoint]\n  );\n  const position = useMemo(\n    () =>\n      block([\n        // debug('current gesture', currentGesture),\n        /**\n         * In case animation get interrupted, we execute the finishTiming node and\n         * set current position the the animated position.\n         */\n        cond(isAnimationInterrupted, [\n          // // debug('animation interrupted', isAnimationInterrupted),\n          finishTiming,\n          set(currentPosition, animationState.position),\n        ]),\n\n        /**\n         * Panning node\n         */\n        cond(isPanning, [\n          set(\n            currentGesture,\n            cond(isPanningContent, GESTURE.CONTENT, GESTURE.HANDLE)\n          ),\n          // debug('start panning', translateY),\n          cond(\n            not(greaterOrEq(add(currentPosition, translateY), 0)),\n            [set(animationState.position, 0), set(animationState.finished, 0)],\n            cond(\n              not(lessOrEq(add(currentPosition, translateY), snapPoints[0])),\n              [\n                set(animationState.position, snapPoints[0]),\n                set(animationState.finished, 0),\n              ],\n              [\n                set(animationState.position, add(currentPosition, translateY)),\n                set(animationState.finished, 0),\n              ]\n            )\n          ),\n        ]),\n\n        /**\n         * Gesture ended node.\n         */\n        onChange(\n          add(contentPanGestureState, handlePanGestureState),\n          cond(\n            or(\n              and(\n                eq(currentGesture, GESTURE.CONTENT),\n                eq(contentPanGestureState, State.END)\n              ),\n              and(\n                eq(currentGesture, GESTURE.HANDLE),\n                eq(handlePanGestureState, State.END)\n              )\n            ),\n            [\n              // debug('gesture end', currentGesture),\n              set(\n                config.toValue,\n                snapPoint(\n                  add(currentPosition, translateY),\n                  velocityY,\n                  snapPoints\n                )\n              ),\n              set(shouldAnimate, 1),\n            ]\n          )\n        ),\n        /**\n         * Manual snapping node.\n         */\n        cond(neq(manualSnapToPoint, -1), [\n          // debug('Manually snap to', manualSnapToPoint),\n          set(config.toValue, manualSnapToPoint),\n          set(animationState.finished, 0),\n          set(shouldAnimate, 1),\n          set(manualSnapToPoint, -1),\n        ]),\n\n        /**\n         * Animation Node.\n         */\n        cond(shouldAnimate, [\n          // debug('start animating', shouldAnimate),\n          cond(and(not(clockRunning(clock)), not(animationState.finished)), [\n            set(animationState.finished, 0),\n            set(animationState.frameTime, 0),\n            set(animationState.time, 0),\n            startClock(clock),\n          ]),\n          timing(clock, animationState, config),\n          cond(animationState.finished, finishTiming),\n        ]),\n\n        animationState.position,\n      ]),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [snapPoints]\n  );\n\n  return {\n    position,\n    manualSnapToPoint,\n    currentPosition,\n    currentGesture,\n  };\n};\n"]}